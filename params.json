{"name":"Object Oriented Javascript Notes","tagline":"Notes on Object Oriented Javascript","body":"#Udacity OOJS Notes\r\n\r\n##Clojures\r\n- Declare global array to keep track of functions even after they have been returned in a lexical scope.\r\n\r\n```\r\nvar sagas = [];\r\nvar hero = newHero();\r\n\r\nvar newSaga = function(){\r\n\tvar foil = newFoil();\r\n\tsagas.push(function(){  // Push will store a function object to the sagas array which will persist.\r\n\t\tvar deed = newDeed();\r\n\t\tlog(deed + log + foil);\r\n\t});\r\n}\r\nnewSaga();\r\n\r\n\t/* \r\n\t\tContext of a function will always be created as a child of the context it was defined within \r\n\t*/\r\nsagas[0]; // Logs \"BoyEyesRat\"\r\n\r\n\t/* \r\n\t\tCreates new context in NEWSAGA1 context ... new deed var will be created \r\n\t*/\r\nsagas[0]; // Logs \"BoyDigsRat\"\r\n\r\n\t/* \r\n\t\tCreates new function to be pushed to sagas array in a new NEWSAGA2 context \r\n\t*/\r\nnewSaga(); \r\n\r\n\t/* \r\n\t\tWill still make lookup to deed var in NEWSAGA1 context \r\n\t*/\r\nsagas[0]; // Logs \"BoyPinsRat\"\r\n\r\n\t/* \r\n\t\tWill make lookup to deed var in NEWSAGA2 context \r\n\t*/\r\nsagas[1]; // Logs \"BoyGetsET\"\r\n\r\n\t/*\r\n\t\tDOES NOT CREATE NEW CONTEXT. uses SAGAS1.3 Context since sagas[1] has been called\r\n\t*/\r\nsagas[0]; // Logs \"BoyPinsRat\"\r\n\r\n```\r\n####Mock Compiler \r\n```\r\n####MAIN \r\n    sagas = [{f}, {f}]\r\n    hero = \"Boy\"\r\n    newSaga = {f}\r\n    ####NEWSAGA1\r\n        foil = \"Rat\"\r\n        ####SAGAS1.1\r\n\t\t\tdeed = \"Eyes\"\r\n\t\t####SAGAS1.2\r\n\t\t\tdeed = \"Digs\"\r\n\t\t####sAGAS1.3\r\n\t\t\tdeed = \"Pins\"\r\n\t####NEWSAGA2\r\n\t\tfoil = \"ET\"\r\n\t\t####SAGAS2.1\r\n\t\t\tdeed = \"Gets\"\r\n```\r\n##'this' Keyword\r\n- this will be automatically bound to the correct object automatically\r\n- How the interpreter knows which binding is correct, resembles the rules for positional function parameters\r\n\r\n####What it DOESN'T map to\r\n```\t\r\nvar obj = { // .. the object created by the literal this appears within\r\n\tfn = function(a,b){ // .. the fn this appears within\r\n\t\tlog(this);\r\n\t}\r\n};\r\n\r\nvar obj2 = {method: obj.fn}; // .. an object that happens to have that fn as a property\r\n\r\nobj.fn(3,4); // .. an \"execution context\"\r\n\r\n```\r\n\r\n####What it DOES map to\r\n```\r\nobj.fn(3,4); // The object to the left of the dot (different from the literal definition!)\r\n```\r\n\r\n####Examples\r\n```\r\nvar fn = function(one, two){\r\n\tlog(this, one, two);\r\n};\r\n\r\nvar r = {}, g = {}, b = {}, y = {};\r\nr.method = fn;\r\n\r\n/* \r\n\tthis becomes the object fn is bound to \r\n*/\r\nr.method(g,b) // r{}, g{}, b{}\r\n\r\n/* \r\n\tthis becomes the global scope fn is within \r\n*/\r\nfn(g,b)       // <global>, g{}, b{}\r\n\r\n/* \r\n\t.call overrides the <global> reference and sets it to the first param *\r\n/ \r\nfn.call(r,g,b) // r{}, g{}, b{}\r\n\r\n/* \r\n\t.call also overrides the method access rules, will be bound to y \r\n*/\r\nr.method.call(y,g,b) // y{}, g{}, b{}\r\n\r\n//USE IN CALLBACKS\r\n/* \r\n\tfn is forced to be invoked without parameters in setTimeout implementation. setTimeout has no way of knowing the input params here\r\n*/\r\nsetTimeout(fn, 1000) // <global>, undefined, undefined \r\n\r\n/* \r\n\tSame as above \r\n*/\r\nsetTimeout(r.method, 1000) // <global>, undefined, undefined\r\n\r\n/* \r\n\tDefine a function without params (since it will be invoked without params anyway) and have it contain the params you desire.\r\n*/\r\nsetTimeout(function(){  // r{}, g{}, b{}\r\n\tr.method(g,b); \t\r\n})\r\n\r\n//Mock Implementation\r\nvar setTimeout = function(cb, ms){\r\n\tarbitraryDelay(ms);\r\n\tcb();\r\n}\r\n\r\nlog(this) // <global>\r\n\r\nnew r.method(g,b) // brand new object\r\n```\r\n\r\n##Prototype Chains\r\nCan copy an object to another object s.t. second object has all properties first one has. OR Can make new object behave like the original by delegating failed lookups to the original one.\r\n\r\n**Why?**\r\nTo save memory/ share code.\r\n\r\n```\r\nvar gold  = {a:1};\r\nlog(gold.a); // 1\r\nlog(gold.z); // undef\r\n\r\n/* This is a ONE-TIME PROPERTY COPY */\r\nvar blue = extend({},gold); // Assume there is for loop copying the values of gold to blue...\r\nlog(blue.z); // undef\r\n\r\n/* this is ONGOING LOOKUP-TIME DELEGATION */ \r\nvar rose = Object.create(gold); //Constantly uses gold as \"fallback\" for property checking\r\nrose.b = 2;\r\nlog(rose.a) // 1\r\nlog(rose.z) // undef\r\n\r\ngold.z = 3;\r\n\r\nlog(blue.z); // undef\r\nlog(rose.z); // 3\r\n\r\n```\r\n####The chain\r\n...Rose has a fallback too, the Object prototype. All objects in JS have a top level prototype to fall back to, the **Object** prototype. Arrays have an independant array prototype, which is delegated to by the Object prototype.\r\n\r\n```\r\n\r\nrose.toString(); //toString() is a top level function that all JS objects have\r\n\r\nvar array1 = [];\r\narray1.constructor() = Array\r\n\r\nvar obj1 = {};\r\nobj1.constructor() = Object\r\n\r\n/*The two vars above have their own constructors dependant on their prorotype! */\r\n\r\n```\r\n\r\n##Object Decorator Pattern\r\n\r\nReusing code!\r\n\r\n```\r\n//run.js\r\nvar amy = {loc:1};\r\namy.loc++;\r\nvar ben = {loc:9};\r\nben.loc++;\r\n\r\n//library.js\r\nvar move = function(car){ // This is a decorator pattern\r\n\tcar.loc++;\r\n};\r\n\r\n//run.js\r\nvar amy = {loc:1};\r\nmove(amy);\r\nvar ben = {loc.9};\r\nmove(ben);\r\n\r\n//library.js\r\nvar carlike = function(obj, loc){ // This is a decorator pattern\r\n\tobj.loc = loc;\r\n\treturn obj;\r\n};\r\n\r\nvar move = function(car){\r\n\tcar.loc++;\r\n};\r\n\r\n//run.js\r\nvar amy = carlike({}, 1);\r\nmove(amy);\r\nvar ben = carlike({}, 9);\r\nmove(ben);\r\n\r\n//library.js\r\nvar carlike = function(obj, loc){ // This is a decorator pattern\r\n\tobj.loc = loc;\r\n\tobj.move = function(){ // New closure scope is created\r\n\t\tobj.loc++;\r\n\t};\r\n\treturn obj;\r\n};\r\n\r\n//run.js\r\nvar amy = carlike({}, 1);\r\namy.move();\r\nvar ben = carlike({}, 9);\r\nben.move();\r\n```\r\n\r\nAbstract out code because\r\n1. Less code\r\n2. Faster refactoring\r\n\r\n##Functional Classes\r\nClasses build the object that it will augment\r\nVS.\r\nDecoraters accept the object that it will augment\r\n\r\n```\r\n/*Class*/\r\ncarlike = function(var){\r\n\t//?...\t\r\n};\r\n\r\n/*Decorator*/\r\ncarlike = function(obj, var){\r\n\t//?....\r\n};\r\n```\r\n\r\n```\r\n//library.js\r\nvar Car = function(loc){\r\n\tvar obj = {loc:loc};\r\n\textend(obj, Car.methods);\r\n\tobj.move = move;\r\n\treturn obj;\r\n};\r\n\r\nCar.methods = {\r\n\tmove : function(){ //Prevents new UNIQUE function \"move\" to be created everytime the object is instantiated\r\n\t\tthis.loc++;\t\r\n\t};\t\r\n};\r\n\r\n\r\n//run.js\r\nvar amy = Car(1);\r\namy.move();\r\nvar ben = Car(9);\r\nben.move();\r\n```\r\n\r\nFunctions can store properties of objects.\r\n\r\n##Prototypal Classes\r\nDelegate lookup of move function to another prototypal class.\r\n\r\n```\r\nvar Car = function(loc){\r\n\tvar obj = Object.create(Car.prototype); // Make new instance objects delegate their failed lookup to Car.methods - NO LONGER NEEDED TO COPY METHODS!\r\n\tobj.loc = loc;\r\n\treturn obj;\r\n};\r\n\r\nCar.methods = {\r\n\tmove : function(){\r\n\t\tthis.loc++;\r\n\t}\r\n};\r\n\r\n/*Built in \".methods object\", this is ONLY naming.*/\r\nCar.prototype.move = function(){\r\n\tthis.loc++;\t\r\n};\r\n\r\nconsole.log(amy.prototype.constructor) // Car\r\nconsole.log(amy instanceof Car) // true , instance of looks to see if there is Car.prototype in amy object\r\n```\r\n1. Function to create object \r\n2. Line to generate instance of object\r\n3. Delegation from new obj to some prototype object\r\n4. Something to augment this object to make it unique from other objects in same class\r\n\r\n...Very common process, JS has built in **.prototype** object to serve EXACT same purpose as **.methods**\r\n\r\namy's prototype is Car.prototype means different than Car's prototype is Car.prototype.\r\nCar is a function object, thus failed lookups will fall back to a **function prototype**, where as amy's prototype is **Car.prototype**\r\n\r\nWhen car functions run, it will delegate their failed lookups to Car.prototype.\r\n\r\n\r\n##Pseudoclassical Patterns\r\nWe can re-write our code so as to use the **new** operator that so many other classes use...\r\n\r\nSyntactic convienience!\r\n```\r\nvar Car = function(loc){\r\n\tvar obj = Object.create(Car.prototype);\r\n\tobj.loc = loc;\r\n\treturn obj;\r\n};\r\n\r\nCar.prototype.move = function(){\r\n\tthis.loc++;\t\r\n};\r\n```\r\n\r\nWill now look like this during interpretation\r\n```\r\n//library.js\r\nvar Car = function(loc){\r\n\tthis = Object.create(Car.prototype); // interpreter inserted\r\n\tthis.loc = loc;\r\n\treturn this; // interpreter inserted\r\n};\r\n\r\nCar.prototype.move = function(){\r\n\tthis.loc++;\t\r\n};\r\n\r\n//run.js\r\nvar ben = new Car(9);\r\nben.move();\r\n```\r\n\r\nWill now **finally** look like this\r\n```\r\n//library.js\r\nvar Car = function(loc){ // Differences between all object instances of this class.\r\n\tthis.loc = loc;\r\n};\r\n\r\nCar.prototype.move = function(){ // Similarities between all object instances of this class.\r\n\tthis.loc++;\t\r\n};\r\n\r\n//run.js\r\nvar ben = new Car(9);\r\nben.move();\r\n```\r\n\r\n##Superclass and Subclasses\r\nCreate a **functional** super class Car that has subclass Van and Cop.\r\n```\r\n//library.js\r\nvar Car = function(){\r\n\tvar obj = {loc:loc};\r\n\tobj.move = function(){\r\n\t\tobj.loc++;\r\n\t};\r\n\treturn obj\r\n};\r\nvar Van = function(loc){\r\n\tvar obj = Car(loc);\r\n\tobj.grab = function{/*...*/};\r\n\treturn obj;\r\n};\r\nvar Cop = function(loc){\r\n\tvar obj = Car(loc);\r\n\tobj.call = function{/*...*/};\r\n\treturn obj;\r\n};\r\n\r\n//run.js\r\nvar amy = Van(1);\r\namy.move();\r\nvar cal = Cop(9);\r\ncal.move();\r\n```\r\n\r\n##Pseudoclassical Subclasses\r\n```\r\nvar Car = function(loc){\r\n\tthis.loc = loc;\r\n};\r\nCar.prototype.move = function(){\r\n\tthis.loc++;\r\n};\r\n\r\nvar Van = function(loc){\r\n\tCar.call(this, loc); // Call JUST  the car constructor in this scope with loc var. No car prototype\r\n};\r\nVan.prototype = Object.create(Car.prototype); // Create delegation of Van.prototype to Car.prototype for failed lookup of .move()\r\n\r\nVan.prototype.grab = function(){/*...*/};\r\nVan.prototype.constructor = Van; // This is lost when we created Van.prototype as a delegation of Car.prototype\r\nvar zed = new Car(3);\r\nzed.move();\r\n\r\nvar amy = new Van(9);\r\namy.move();\r\namy.grab();\r\n```\r\n\r\n*N.B.: Van.prototype = new Car() is still used by alot of people for delegating failed calls from Van.protoytpe to Car.prototype*","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}