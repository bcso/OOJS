<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Object Oriented Javascript Notes by bcso</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Object Oriented Javascript Notes</h1>
        <h2>Notes on Object Oriented Javascript</h2>
        <a href="https://github.com/bcso/OOJS" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>
<a id="udacity-oojs-notes" class="anchor" href="#udacity-oojs-notes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Udacity OOJS Notes</h1>

<h2>
<a id="clojures" class="anchor" href="#clojures" aria-hidden="true"><span class="octicon octicon-link"></span></a>Clojures</h2>

<ul>
<li>Declare global array to keep track of functions even after they have been returned in a lexical scope.</li>
</ul>

<pre><code>var sagas = [];
var hero = newHero();

var newSaga = function(){
    var foil = newFoil();
    sagas.push(function(){  // Push will store a function object to the sagas array which will persist.
        var deed = newDeed();
        log(deed + log + foil);
    });
}
newSaga();

    /* 
        Context of a function will always be created as a child of the context it was defined within 
    */
sagas[0]; // Logs "BoyEyesRat"

    /* 
        Creates new context in NEWSAGA1 context ... new deed var will be created 
    */
sagas[0]; // Logs "BoyDigsRat"

    /* 
        Creates new function to be pushed to sagas array in a new NEWSAGA2 context 
    */
newSaga(); 

    /* 
        Will still make lookup to deed var in NEWSAGA1 context 
    */
sagas[0]; // Logs "BoyPinsRat"

    /* 
        Will make lookup to deed var in NEWSAGA2 context 
    */
sagas[1]; // Logs "BoyGetsET"

    /*
        DOES NOT CREATE NEW CONTEXT. uses SAGAS1.3 Context since sagas[1] has been called
    */
sagas[0]; // Logs "BoyPinsRat"

</code></pre>

<h4>
<a id="mock-compiler" class="anchor" href="#mock-compiler" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mock Compiler</h4>

<pre><code>####MAIN 
    sagas = [{f}, {f}]
    hero = "Boy"
    newSaga = {f}
    ####NEWSAGA1
        foil = "Rat"
        ####SAGAS1.1
            deed = "Eyes"
        ####SAGAS1.2
            deed = "Digs"
        ####sAGAS1.3
            deed = "Pins"
    ####NEWSAGA2
        foil = "ET"
        ####SAGAS2.1
            deed = "Gets"
</code></pre>

<h2>
<a id="this-keyword" class="anchor" href="#this-keyword" aria-hidden="true"><span class="octicon octicon-link"></span></a>'this' Keyword</h2>

<ul>
<li>this will be automatically bound to the correct object automatically</li>
<li>How the interpreter knows which binding is correct, resembles the rules for positional function parameters</li>
</ul>

<h4>
<a id="what-it-doesnt-map-to" class="anchor" href="#what-it-doesnt-map-to" aria-hidden="true"><span class="octicon octicon-link"></span></a>What it DOESN'T map to</h4>

<pre><code>var obj = { // .. the object created by the literal this appears within
    fn = function(a,b){ // .. the fn this appears within
        log(this);
    }
};

var obj2 = {method: obj.fn}; // .. an object that happens to have that fn as a property

obj.fn(3,4); // .. an "execution context"

</code></pre>

<h4>
<a id="what-it-does-map-to" class="anchor" href="#what-it-does-map-to" aria-hidden="true"><span class="octicon octicon-link"></span></a>What it DOES map to</h4>

<pre><code>obj.fn(3,4); // The object to the left of the dot (different from the literal definition!)
</code></pre>

<h4>
<a id="examples" class="anchor" href="#examples" aria-hidden="true"><span class="octicon octicon-link"></span></a>Examples</h4>

<pre><code>var fn = function(one, two){
    log(this, one, two);
};

var r = {}, g = {}, b = {}, y = {};
r.method = fn;

/* 
    this becomes the object fn is bound to 
*/
r.method(g,b) // r{}, g{}, b{}

/* 
    this becomes the global scope fn is within 
*/
fn(g,b)       // &lt;global&gt;, g{}, b{}

/* 
    .call overrides the &lt;global&gt; reference and sets it to the first param *
/ 
fn.call(r,g,b) // r{}, g{}, b{}

/* 
    .call also overrides the method access rules, will be bound to y 
*/
r.method.call(y,g,b) // y{}, g{}, b{}

//USE IN CALLBACKS
/* 
    fn is forced to be invoked without parameters in setTimeout implementation. setTimeout has no way of knowing the input params here
*/
setTimeout(fn, 1000) // &lt;global&gt;, undefined, undefined 

/* 
    Same as above 
*/
setTimeout(r.method, 1000) // &lt;global&gt;, undefined, undefined

/* 
    Define a function without params (since it will be invoked without params anyway) and have it contain the params you desire.
*/
setTimeout(function(){  // r{}, g{}, b{}
    r.method(g,b);  
})

//Mock Implementation
var setTimeout = function(cb, ms){
    arbitraryDelay(ms);
    cb();
}

log(this) // &lt;global&gt;

new r.method(g,b) // brand new object
</code></pre>

<h2>
<a id="prototype-chains" class="anchor" href="#prototype-chains" aria-hidden="true"><span class="octicon octicon-link"></span></a>Prototype Chains</h2>

<p>Can copy an object to another object s.t. second object has all properties first one has. OR Can make new object behave like the original by delegating failed lookups to the original one.</p>

<p><strong>Why?</strong>
To save memory/ share code.</p>

<pre><code>var gold  = {a:1};
log(gold.a); // 1
log(gold.z); // undef

/* This is a ONE-TIME PROPERTY COPY */
var blue = extend({},gold); // Assume there is for loop copying the values of gold to blue...
log(blue.z); // undef

/* this is ONGOING LOOKUP-TIME DELEGATION */ 
var rose = Object.create(gold); //Constantly uses gold as "fallback" for property checking
rose.b = 2;
log(rose.a) // 1
log(rose.z) // undef

gold.z = 3;

log(blue.z); // undef
log(rose.z); // 3

</code></pre>

<h4>
<a id="the-chain" class="anchor" href="#the-chain" aria-hidden="true"><span class="octicon octicon-link"></span></a>The chain</h4>

<p>...Rose has a fallback too, the Object prototype. All objects in JS have a top level prototype to fall back to, the <strong>Object</strong> prototype. Arrays have an independant array prototype, which is delegated to by the Object prototype.</p>

<pre><code>
rose.toString(); //toString() is a top level function that all JS objects have

var array1 = [];
array1.constructor() = Array

var obj1 = {};
obj1.constructor() = Object

/*The two vars above have their own constructors dependant on their prorotype! */

</code></pre>

<h2>
<a id="object-decorator-pattern" class="anchor" href="#object-decorator-pattern" aria-hidden="true"><span class="octicon octicon-link"></span></a>Object Decorator Pattern</h2>

<p>Reusing code!</p>

<pre><code>//run.js
var amy = {loc:1};
amy.loc++;
var ben = {loc:9};
ben.loc++;

//library.js
var move = function(car){ // This is a decorator pattern
    car.loc++;
};

//run.js
var amy = {loc:1};
move(amy);
var ben = {loc.9};
move(ben);

//library.js
var carlike = function(obj, loc){ // This is a decorator pattern
    obj.loc = loc;
    return obj;
};

var move = function(car){
    car.loc++;
};

//run.js
var amy = carlike({}, 1);
move(amy);
var ben = carlike({}, 9);
move(ben);

//library.js
var carlike = function(obj, loc){ // This is a decorator pattern
    obj.loc = loc;
    obj.move = function(){ // New closure scope is created
        obj.loc++;
    };
    return obj;
};

//run.js
var amy = carlike({}, 1);
amy.move();
var ben = carlike({}, 9);
ben.move();
</code></pre>

<p>Abstract out code because
1. Less code
2. Faster refactoring</p>

<h2>
<a id="functional-classes" class="anchor" href="#functional-classes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Functional Classes</h2>

<p>Classes build the object that it will augment
VS.
Decoraters accept the object that it will augment</p>

<pre><code>/*Class*/
carlike = function(var){
    //?...  
};

/*Decorator*/
carlike = function(obj, var){
    //?....
};
</code></pre>

<pre><code>//library.js
var Car = function(loc){
    var obj = {loc:loc};
    extend(obj, Car.methods);
    obj.move = move;
    return obj;
};

Car.methods = {
    move : function(){ //Prevents new UNIQUE function "move" to be created everytime the object is instantiated
        this.loc++; 
    };  
};


//run.js
var amy = Car(1);
amy.move();
var ben = Car(9);
ben.move();
</code></pre>

<p>Functions can store properties of objects.</p>

<h2>
<a id="prototypal-classes" class="anchor" href="#prototypal-classes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Prototypal Classes</h2>

<p>Delegate lookup of move function to another prototypal class.</p>

<pre><code>var Car = function(loc){
    var obj = Object.create(Car.prototype); // Make new instance objects delegate their failed lookup to Car.methods - NO LONGER NEEDED TO COPY METHODS!
    obj.loc = loc;
    return obj;
};

Car.methods = {
    move : function(){
        this.loc++;
    }
};

/*Built in ".methods object", this is ONLY naming.*/
Car.prototype.move = function(){
    this.loc++; 
};

console.log(amy.prototype.constructor) // Car
console.log(amy instanceof Car) // true , instance of looks to see if there is Car.prototype in amy object
</code></pre>

<ol>
<li>Function to create object </li>
<li>Line to generate instance of object</li>
<li>Delegation from new obj to some prototype object</li>
<li>Something to augment this object to make it unique from other objects in same class</li>
</ol>

<p>...Very common process, JS has built in <strong>.prototype</strong> object to serve EXACT same purpose as <strong>.methods</strong></p>

<p>amy's prototype is Car.prototype means different than Car's prototype is Car.prototype.
Car is a function object, thus failed lookups will fall back to a <strong>function prototype</strong>, where as amy's prototype is <strong>Car.prototype</strong></p>

<p>When car functions run, it will delegate their failed lookups to Car.prototype.</p>

<h2>
<a id="pseudoclassical-patterns" class="anchor" href="#pseudoclassical-patterns" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pseudoclassical Patterns</h2>

<p>We can re-write our code so as to use the <strong>new</strong> operator that so many other classes use...</p>

<p>Syntactic convienience!</p>

<pre><code>var Car = function(loc){
    var obj = Object.create(Car.prototype);
    obj.loc = loc;
    return obj;
};

Car.prototype.move = function(){
    this.loc++; 
};
</code></pre>

<p>Will now look like this during interpretation</p>

<pre><code>//library.js
var Car = function(loc){
    this = Object.create(Car.prototype); // interpreter inserted
    this.loc = loc;
    return this; // interpreter inserted
};

Car.prototype.move = function(){
    this.loc++; 
};

//run.js
var ben = new Car(9);
ben.move();
</code></pre>

<p>Will now <strong>finally</strong> look like this</p>

<pre><code>//library.js
var Car = function(loc){ // Differences between all object instances of this class.
    this.loc = loc;
};

Car.prototype.move = function(){ // Similarities between all object instances of this class.
    this.loc++; 
};

//run.js
var ben = new Car(9);
ben.move();
</code></pre>

<h2>
<a id="superclass-and-subclasses" class="anchor" href="#superclass-and-subclasses" aria-hidden="true"><span class="octicon octicon-link"></span></a>Superclass and Subclasses</h2>

<p>Create a <strong>functional</strong> super class Car that has subclass Van and Cop.</p>

<pre><code>//library.js
var Car = function(){
    var obj = {loc:loc};
    obj.move = function(){
        obj.loc++;
    };
    return obj
};
var Van = function(loc){
    var obj = Car(loc);
    obj.grab = function{/*...*/};
    return obj;
};
var Cop = function(loc){
    var obj = Car(loc);
    obj.call = function{/*...*/};
    return obj;
};

//run.js
var amy = Van(1);
amy.move();
var cal = Cop(9);
cal.move();
</code></pre>

<h2>
<a id="pseudoclassical-subclasses" class="anchor" href="#pseudoclassical-subclasses" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pseudoclassical Subclasses</h2>

<pre><code>var Car = function(loc){
    this.loc = loc;
};
Car.prototype.move = function(){
    this.loc++;
};

var Van = function(loc){
    Car.call(this, loc); // Call JUST  the car constructor in this scope with loc var. No car prototype
};
Van.prototype = Object.create(Car.prototype); // Create delegation of Van.prototype to Car.prototype for failed lookup of .move()

Van.prototype.grab = function(){/*...*/};
Van.prototype.constructor = Van; // This is lost when we created Van.prototype as a delegation of Car.prototype
var zed = new Car(3);
zed.move();

var amy = new Van(9);
amy.move();
amy.grab();
</code></pre>

<p><em>N.B.: Van.prototype = new Car() is still used by alot of people for delegating failed calls from Van.protoytpe to Car.prototype</em></p>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/bcso/OOJS/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/bcso/OOJS/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/bcso/OOJS"></a> is maintained by <a href="https://github.com/bcso">bcso</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
